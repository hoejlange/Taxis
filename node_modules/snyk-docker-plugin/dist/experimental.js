"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = require("fs");
const os = require("os");
const path = require("path");
const image_inspector_1 = require("./analyzer/image-inspector");
const docker_1 = require("./docker");
const staticModule = require("./static");
const types_1 = require("./types");
function experimentalAnalysis(targetImage, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // assume Distroless scanning
        return distroless(targetImage, options);
    });
}
exports.experimentalAnalysis = experimentalAnalysis;
// experimental flow expected to be merged with the static analysis when ready
function distroless(targetImage, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (staticModule.isRequestingStaticAnalysis(options)) {
            return staticModule.analyzeStatically(targetImage, options);
        }
        yield image_inspector_1.pullIfNotLocal(targetImage);
        const archiveDir = path.join(os.tmpdir(), "snyk-image-archives");
        createTempDirIfMissing(archiveDir);
        // TODO terrible way to convert slashes to anything else
        // so we don't think it's a directory
        const archiveFileName = `${targetImage.replace(/\//g, "__")}.tar`;
        const archiveFullPath = path.join(archiveDir, archiveFileName);
        // assumption #1: the `docker` binary is available locally
        const docker = new docker_1.Docker(targetImage);
        yield docker.save(targetImage, archiveFullPath);
        try {
            const scanningOptions = {
                staticAnalysisOptions: {
                    imagePath: archiveFullPath,
                    imageType: types_1.ImageType.DockerArchive,
                    // TODO only for RPM, may be removed once we get rid of bdb dep
                    tmpDirPath: "",
                    distroless: true,
                },
            };
            return staticModule.analyzeStatically(targetImage, scanningOptions);
        }
        finally {
            fs.unlinkSync(archiveFullPath);
        }
    });
}
exports.distroless = distroless;
function createTempDirIfMissing(archiveDir) {
    try {
        fs.mkdirSync(archiveDir);
    }
    catch (err) {
        if (err.code !== "EEXIST") {
            throw err;
        }
    }
}
//# sourceMappingURL=experimental.js.map